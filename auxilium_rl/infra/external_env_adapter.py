"""External environment adapter interface and implementations."""
from abc import ABC, abstractmethod
from typing import Tuple, Dict, Any, Optional
import logging
import numpy as np
import grpc

logger = logging.getLogger(__name__)


class ExternalEnvAdapter(ABC):
    """Abstract interface for external environment communication."""
    
    @abstractmethod
    def reset(self, seed: Optional[int] = None) -> np.ndarray:
        """
        Reset the environment.
        
        Args:
            seed: Random seed for reproducibility
            
        Returns:
            Initial observation
        """
        pass
    
    @abstractmethod
    def step(self, action: int) -> Tuple[np.ndarray, float, bool, bool, Dict[str, Any]]:
        """
        Execute one step in the environment.
        
        Args:
            action: Action to take
            
        Returns:
            Tuple of (observation, reward, terminated, truncated, info)
        """
        pass
    
    @abstractmethod
    def close(self) -> None:
        """Clean up resources."""
        pass


class FakeExternalEnvAdapter(ExternalEnvAdapter):
    """
    Simple in-memory fake adapter for testing.
    Implements a deterministic cartpole-like environment.
    """
    
    def __init__(self, observation_dim: int = 4, action_dim: int = 4):
        """
        Initialize the fake adapter.
        
        Args:
            observation_dim: Dimensionality of observation space
            action_dim: Number of discrete actions
        """
        self.observation_dim = observation_dim
        self.action_dim = action_dim
        self.state = None
        self.steps = 0
        self._rng = np.random.RandomState()
    
    def reset(self, seed: Optional[int] = None) -> np.ndarray:
        """Reset to a random initial state."""
        if seed is not None:
            self._rng = np.random.RandomState(seed)
        
        self.state = self._rng.randn(self.observation_dim) * 0.1
        self.steps = 0
        return self.state.copy()
    
    def step(self, action: int) -> Tuple[np.ndarray, float, bool, bool, Dict[str, Any]]:
        """
        Execute a simple transition with deterministic dynamics.
        
        The fake environment provides simple feedback:
        - Reward is based on staying close to zero
        - Episode terminates if state goes too far from origin
        """
        if self.state is None:
            raise RuntimeError("Must call reset() before step()")
        
        # Simple dynamics: state drifts slightly based on action
        action_effect = (action - self.action_dim / 2) * 0.1
        self.state = self.state + self._rng.randn(self.observation_dim) * 0.05 + action_effect
        
        # Reward: negative distance from origin
        distance = np.linalg.norm(self.state)
        reward = float(-distance * 0.1)
        
        # Terminate if too far
        terminated = bool(distance > 3.0)
        
        self.steps += 1
        
        info = {
            "steps": self.steps,
            "distance": float(distance)
        }
        
        return self.state.copy(), reward, terminated, False, info
    
    def close(self) -> None:
        """No resources to clean up."""
        pass


class GrpcExternalEnvAdapter(ExternalEnvAdapter):
    """
    Adapter that communicates with external .NET simulation via gRPC.
    
    Connects to the .NET SimulationService and forwards reset/step/close calls.
    """
    
    def __init__(self, grpc_endpoint: str):
        """
        Initialize the gRPC adapter.
        
        Args:
            grpc_endpoint: Address of the .NET simulation gRPC server (e.g., "localhost:50051")
        """
        self.grpc_endpoint = grpc_endpoint
        self._channel = None
        self._stub = None
        self._connect()
    
    def _connect(self) -> None:
        """Establish gRPC channel and create stub."""
        try:
            # Import generated proto classes (will be generated by protoc)
            from generated import simulation_pb2, simulation_pb2_grpc
            
            self._channel = grpc.insecure_channel(self.grpc_endpoint)
            self._stub = simulation_pb2_grpc.SimulationServiceStub(self._channel)
            
            # Test connection with a quick channel ready check
            grpc.channel_ready_future(self._channel).result(timeout=5)
            logger.info(f"Connected to .NET simulation at {self.grpc_endpoint}")
            
        except ImportError as e:
            raise ImportError(
                "Generated simulation proto files not found. "
                "Run: python -m grpc_tools.protoc -I./proto --python_out=./generated "
                "--grpc_python_out=./generated proto/simulation.proto"
            ) from e
        except grpc.FutureTimeoutError as e:
            raise ConnectionError(
                f"Failed to connect to .NET simulation at {self.grpc_endpoint}. "
                "Ensure the .NET gRPC host is running."
            ) from e
    
    def reset(self, seed: Optional[int] = None) -> np.ndarray:
        """
        Send reset request to .NET simulation via gRPC.
        
        Args:
            seed: Random seed for reproducibility
            
        Returns:
            Initial observation as numpy array
        """
        from generated import simulation_pb2
        
        try:
            request = simulation_pb2.ResetRequest(seed=seed if seed is not None else 0)
            response = self._stub.Reset(request, timeout=10)
            
            observation = np.array(response.observation, dtype=np.float32)
            logger.debug(f"Reset completed. Observation shape: {observation.shape}")
            
            return observation
            
        except grpc.RpcError as e:
            logger.error(f"gRPC error during reset: {e}")
            raise RuntimeError(f"Failed to reset .NET simulation: {e}") from e
    
    def step(self, action: int) -> Tuple[np.ndarray, float, bool, bool, Dict[str, Any]]:
        """
        Send step request to .NET simulation via gRPC.
        
        Args:
            action: Action to take
            
        Returns:
            Tuple of (observation, reward, terminated, truncated, info)
        """
        from generated import simulation_pb2
        
        try:
            request = simulation_pb2.StepRequest(action=action)
            response = self._stub.Step(request, timeout=10)
            
            observation = np.array(response.observation, dtype=np.float32)
            reward = float(response.reward)
            terminated = bool(response.terminated)
            truncated = bool(response.truncated)
            info = dict(response.info)  # Convert protobuf map to dict
            
            logger.debug(
                f"Step completed. Action: {action}, Reward: {reward}, "
                f"Terminated: {terminated}, Truncated: {truncated}"
            )
            
            return observation, reward, terminated, truncated, info
            
        except grpc.RpcError as e:
            logger.error(f"gRPC error during step: {e}")
            raise RuntimeError(f"Failed to step .NET simulation: {e}") from e
    
    def close(self) -> None:
        """Close gRPC channel."""
        from generated import simulation_pb2
        
        try:
            if self._stub is not None:
                request = simulation_pb2.CloseRequest()
                response = self._stub.Close(request, timeout=5)
                logger.info(f"Simulation closed: {response.message}")
        except grpc.RpcError as e:
            logger.warning(f"Error closing simulation: {e}")
        finally:
            if self._channel is not None:
                self._channel.close()
                logger.info("gRPC channel closed")

